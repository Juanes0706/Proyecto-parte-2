-- Script para resolver problemas de compatibilidad entre tablas buses e imagenes

-- 0. Crear secuencia para id si no existe
CREATE SEQUENCE IF NOT EXISTS imagenes_id_seq;

-- 1. Verificar tipos de datos actuales
DO $$ 
DECLARE
    buses_id_type TEXT;
    imagenes_busid_type TEXT;
    estaciones_id_type TEXT;
    imagenes_id_type TEXT;
BEGIN
    -- Obtener tipo de datos de buses.id
    SELECT data_type INTO buses_id_type 
    FROM information_schema.columns 
    WHERE table_name = 'buses' AND column_name = 'id';

    -- Obtener tipo de datos de estaciones.id
    SELECT data_type INTO estaciones_id_type 
    FROM information_schema.columns 
    WHERE table_name = 'estaciones' AND column_name = 'id';

    -- Obtener tipo de datos de imagenes.id
    SELECT data_type INTO imagenes_id_type 
    FROM information_schema.columns 
    WHERE table_name = 'imagenes' AND column_name = 'id';

    -- Obtener tipo de datos de imagenes.bus_id
    SELECT data_type INTO imagenes_busid_type 
    FROM information_schema.columns 
    WHERE table_name = 'imagenes' AND column_name = 'bus_id';

    RAISE NOTICE 'Tipo de datos buses.id: %', buses_id_type;
    RAISE NOTICE 'Tipo de datos estaciones.id: %', estaciones_id_type;
    RAISE NOTICE 'Tipo de datos imagenes.id: %', imagenes_id_type;
    RAISE NOTICE 'Tipo de datos imagenes.bus_id: %', imagenes_busid_type;

    -- Verificar si la tabla imagenes existe pero está mal configurada
    IF imagenes_id_type IS NULL THEN
        RAISE NOTICE 'La tabla imagenes no existe, se creará con los tipos correctos';
        RETURN;
    END IF;

    -- Si los tipos ya son iguales, no hacer nada
    IF buses_id_type = imagenes_busid_type THEN
        RAISE NOTICE 'Los tipos de datos son compatibles, no se requieren cambios';
        RETURN;
    END IF;

    -- SOLUCIÓN: Vamos a recrear la tabla imagenes correctamente
    RAISE NOTICE 'Recreando tabla imagenes con tipos compatibles...';

    -- Backup de datos existentes si es posible
    BEGIN
        CREATE TABLE IF NOT EXISTS imagenes_backup AS SELECT * FROM imagenes;
        RAISE NOTICE 'Backup de datos creado en tabla imagenes_backup';
    EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'No se pudo crear backup: %', SQLERRM;
    END;

    -- Eliminar tabla imagenes y sus restricciones
    DROP TABLE IF EXISTS imagenes CASCADE;
    RAISE NOTICE 'Tabla imagenes eliminada';

    -- Recrear la tabla con el tipo correcto (BIGINT que es lo más común)
    IF buses_id_type = 'bigint' THEN
        -- Crear tabla con BIGINT
        CREATE TABLE imagenes (
            id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            url TEXT NOT NULL,
            bus_id BIGINT REFERENCES buses(id) ON DELETE CASCADE,
            estacion_id BIGINT REFERENCES estaciones(id) ON DELETE CASCADE,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
        );
        RAISE NOTICE 'Tabla imagenes creada con tipo BIGINT';
    ELSE
        -- Crear tabla con UUID
        CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
        CREATE TABLE imagenes (
            id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
            url TEXT NOT NULL,
            bus_id UUID REFERENCES buses(id) ON DELETE CASCADE,
            estacion_id UUID REFERENCES estaciones(id) ON DELETE CASCADE,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
        );
        RAISE NOTICE 'Tabla imagenes creada con tipo UUID';
    END IF;

    -- Recrear índices
    CREATE INDEX IF NOT EXISTS idx_imagenes_bus_id ON imagenes(bus_id);
    CREATE INDEX IF NOT EXISTS idx_imagenes_estacion_id ON imagenes(estacion_id);

    -- Intentar restaurar datos si es posible
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'imagenes_backup') THEN
            -- Si los tipos son diferentes, no podemos restaurar directamente
            IF buses_id_type = 'bigint' THEN
                INSERT INTO imagenes (url, created_at)
                SELECT url, created_at FROM imagenes_backup;
                RAISE NOTICE 'Datos parcialmente restaurados (sin IDs de referencia)';
            ELSE
                INSERT INTO imagenes (url, created_at)
                SELECT url, created_at FROM imagenes_backup;
                RAISE NOTICE 'Datos parcialmente restaurados (sin IDs de referencia)';
            END IF;
        END IF;
    EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'No se pudieron restaurar los datos: %', SQLERRM;
    END;
END $$;

-- 2. Verificar estructura final
SELECT 
    table_name,
    column_name,
    data_type,
    column_default,
    is_nullable
FROM 
    information_schema.columns
WHERE 
    table_name IN ('buses', 'imagenes', 'estaciones')
    AND column_name IN ('id', 'bus_id', 'estacion_id')
ORDER BY 
    table_name, column_name;

-- 3. Verificar restricciones de clave foránea
SELECT 
    tc.constraint_name, 
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name 
FROM 
    information_schema.table_constraints AS tc 
    JOIN information_schema.key_column_usage AS kcu
      ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage AS ccu 
      ON ccu.constraint_name = tc.constraint_name
WHERE 
    constraint_type = 'FOREIGN KEY' 
    AND tc.table_name='imagenes';

-- 4. Mensaje final
DO $$ 
BEGIN
    RAISE NOTICE 'Script de compatibilidad completado. Por favor verifica que las restricciones sean correctas.';
    RAISE NOTICE 'Si encuentras problemas con imágenes, utiliza el endpoint /api/debug/diagnostico-imagen/ID_BUS para diagnosticar.';
END $$;
    FROM information_schema.columns 
    WHERE table_name = 'buses' AND column_name = 'id';

    -- Obtener tipo de datos de imagenes.bus_id
    SELECT data_type INTO imagenes_busid_type 
    FROM information_schema.columns 
    WHERE table_name = 'imagenes' AND column_name = 'bus_id';

    RAISE NOTICE 'Tipo de datos buses.id: %', buses_id_type;
    RAISE NOTICE 'Tipo de datos imagenes.bus_id: %', imagenes_busid_type;

    -- Solo proceder si hay diferencia
    IF buses_id_type != imagenes_busid_type AND buses_id_type IS NOT NULL AND imagenes_busid_type IS NOT NULL THEN
        RAISE NOTICE 'Tipos incompatibles detectados. Corrigiendo...';
    ELSE
        RAISE NOTICE 'No se requieren cambios o alguna tabla no existe';
        RETURN;
    END IF;

    -- Verificar qué tipo debemos usar (preferimos BIGINT)
    IF buses_id_type = 'bigint' THEN
        -- Necesitamos cambiar imagenes.bus_id a BIGINT
        BEGIN
            -- Intentar eliminar restricción existente si hay
            ALTER TABLE imagenes DROP CONSTRAINT IF EXISTS imagenes_bus_id_fkey;
            RAISE NOTICE 'Restricción de clave foránea eliminada';

            -- Cambiar tipo de datos
            ALTER TABLE imagenes ALTER COLUMN bus_id TYPE BIGINT USING NULL;
            RAISE NOTICE 'Columna bus_id cambiada a BIGINT';

            -- Recrear restricción
            ALTER TABLE imagenes ADD CONSTRAINT imagenes_bus_id_fkey
            FOREIGN KEY (bus_id) REFERENCES buses(id) ON DELETE CASCADE;
            RAISE NOTICE 'Restricción de clave foránea recreada';
        EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error al modificar bus_id: %', SQLERRM;
        END;

        -- Hacer lo mismo para estacion_id si es necesario
        BEGIN
            ALTER TABLE imagenes DROP CONSTRAINT IF EXISTS imagenes_estacion_id_fkey;
            ALTER TABLE imagenes ALTER COLUMN estacion_id TYPE BIGINT USING NULL;
            ALTER TABLE imagenes ADD CONSTRAINT imagenes_estacion_id_fkey
            FOREIGN KEY (estacion_id) REFERENCES estaciones(id) ON DELETE CASCADE;
            RAISE NOTICE 'Columna estacion_id actualizada';
        EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error al modificar estacion_id: %', SQLERRM;
        END;
    ELSIF buses_id_type = 'uuid' AND imagenes_busid_type = 'bigint' THEN
        -- Necesitamos cambiar imagenes.bus_id a UUID
        BEGIN
            ALTER TABLE imagenes DROP CONSTRAINT IF EXISTS imagenes_bus_id_fkey;
            ALTER TABLE imagenes ALTER COLUMN bus_id TYPE UUID USING NULL;
            ALTER TABLE imagenes ADD CONSTRAINT imagenes_bus_id_fkey
            FOREIGN KEY (bus_id) REFERENCES buses(id) ON DELETE CASCADE;
            RAISE NOTICE 'Columna bus_id cambiada a UUID';
        EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error al modificar bus_id: %', SQLERRM;
        END;

        -- Hacer lo mismo para estacion_id
        BEGIN
            ALTER TABLE imagenes DROP CONSTRAINT IF EXISTS imagenes_estacion_id_fkey;
            ALTER TABLE imagenes ALTER COLUMN estacion_id TYPE UUID USING NULL;
            ALTER TABLE imagenes ADD CONSTRAINT imagenes_estacion_id_fkey
            FOREIGN KEY (estacion_id) REFERENCES estaciones(id) ON DELETE CASCADE;
            RAISE NOTICE 'Columna estacion_id actualizada';
        EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error al modificar estacion_id: %', SQLERRM;
        END;
    END IF;
END $$;

-- 2. Verificar estructura final
SELECT 
    table_name,
    column_name,
    data_type,
    is_nullable
FROM 
    information_schema.columns
WHERE 
    table_name IN ('buses', 'imagenes', 'estaciones')
    AND column_name IN ('id', 'bus_id', 'estacion_id')
ORDER BY 
    table_name, column_name;

-- 3. Verificar restricciones de clave foránea
SELECT 
    tc.constraint_name, 
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name 
FROM 
    information_schema.table_constraints AS tc 
    JOIN information_schema.key_column_usage AS kcu
      ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage AS ccu 
      ON ccu.constraint_name = tc.constraint_name
WHERE 
    constraint_type = 'FOREIGN KEY' 
    AND tc.table_name='imagenes';

-- 4. Asegurar que la tabla tiene el id como BIGSERIAL si es compatible
DO $$ 
DECLARE
    buses_id_type TEXT;
BEGIN
    SELECT data_type INTO buses_id_type 
    FROM information_schema.columns 
    WHERE table_name = 'buses' AND column_name = 'id';

    IF buses_id_type = 'bigint' THEN
        -- Asegurarse de que la tabla imagenes tiene id BIGSERIAL
        BEGIN
            -- Primero eliminar restricciones existentes
            ALTER TABLE imagenes DROP CONSTRAINT IF EXISTS imagenes_pkey;

            -- Cambiar tipo de id
            ALTER TABLE imagenes ALTER COLUMN id TYPE BIGINT;
            ALTER TABLE imagenes ALTER COLUMN id SET DEFAULT nextval('imagenes_id_seq');
            ALTER TABLE imagenes ADD PRIMARY KEY (id);

            RAISE NOTICE 'Tabla imagenes actualizada con id BIGSERIAL';
        EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error al configurar secuencia: %', SQLERRM;
        END;
    END IF;
END $$;
